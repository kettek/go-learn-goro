# Mapping: The GameMap
With our Tile type now in place, we can create a new file in our **mapping** directory called **gamemap.go**. This GameMap will hold the map structure and important functions for map generation.

## Code Analysis

```
+package mapping
```
Here we are declaring our GameMap type to exist in our mapping package.

---
```
+// GameMap is our map data type.
+type GameMap struct {
+	Width, Height int
+	Tiles         [][]Tile
+}
```
This is our `GameMap` type that contains the map's width, height, and two-dimensional slice of Tile types.

---
```
+// Initialize initializes a GameMap's Tiles to match its Width and Height. It also sets up some coordinates to block movement and sight.
+func (g *GameMap) Initialize() {
+	g.Tiles = make([][]Tile, g.Width)
+
+	for x := range g.Tiles {
+		g.Tiles[x] = make([]Tile, g.Height)
+	}
```
Here is our GameMap's `Initialize()` function that we use to create its two-dimensional slice of Tile types. We are first using golang's built-in [https://tour.golang.org/moretypes/13](make(...)) function to create a slice of slices of Tiles up to the map's width. After this we iterate over each column of `g.Tiles` and create a slice of Tiles within each up to the map's height.

---
```
+	g.Tiles[30][22] = Tile{
+		Flags: BlockMovement | BlockSight,
+	}
+	g.Tiles[31][22] = Tile{
+		Flags: BlockMovement | BlockSight,
+	}
+	g.Tiles[32][22] = Tile{
+		Flags: BlockMovement | BlockSight,
+	}
+}
```
Now we are setting three tiles at **30x22**, **31x22**, and **32x22** to both block movement and sight. We are using the bitwise **|** operator to join the **BlockMovement** and **BlockSight** flag constants, providing a merged value containing both of their bits. And, lastly, we are closing the function with the curly brace on the last line.

---
```
+// IsBlocked returns if the given coordinates are blocking movement.
+func (g *GameMap) IsBlocked(x, y int) bool {
+  // Always block if outside our GameMap's bounds.
+  if x < 0 || x >= g.Width || y < 0 || y >= g.Height {
+    return true
+  }
+	return g.Tiles[y][x].Flags&BlockMovement != 0
+}
```
`IsBlocked(...)` simply returns a boolean representing whether or not a given tile blocks movement. We are also checking if the requested coordinates are smaller than 0 or larger than our Width and Height, and if so, to return as if blocking. For the return value, we are using the bitwise **&** operator to effectively multiply the Tile's individual bits with BlockMovement's bits. This effectively filters out all bits that are not contained by BlockMovement. If the resulting value is non-zero, then the Tile does have the BlockMovement bit set.

## Topics Covered
We have created the `GameMap` type that uses our Tile type and will create few dummy tiles for testing.

## What's Next
Now we will move on to integrating the `GameMap` with our main program.
