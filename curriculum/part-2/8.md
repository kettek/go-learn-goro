# Rendering with the GameMap
We must now return to our **render.go** file and make some changes so we can actually see our GameMap!

## Code Analysis
```
import (
	"github.com/kettek/goro"

	"myproject/entity"
+  "myproject/mapping"
)
```
Here we have added our mapping package to our render file.

---
```
-// DrawAll draws all entities to the screen and flushes it.
-func DrawAll(screen *goro.Screen, entities []*entity.Entity) {
+// DrawAll draws all entities and the gameMap to the screen and flushes it.
+func DrawAll(screen *goro.Screen, entities []*entity.Entity, gameMap mapping.GameMap, colors map[string]goro.Color) {
+  // Draw all the tiles within the game map.
+  for x, column := range gameMap.Tiles {
+    for y, tile := range column {
+      if tile.BlockSight {
+        screen.SetBackground(x, y, colors["darkWall"])
+      } else {
+        screen.SetBackground(x, y, colors["darkGround"])
+      }
+    }
+  }
+	// Draw all the entities.
	for _, entity := range entities {
		DrawEntity(screen, entity)
  }
```
Here we have a fairly large addition that iterates through columns, then through each tile within the column. Within this iteration, we choose to either draw the "darkWall" or the "darkGround" background color if the tile in question blocks sight.

It is worth reminding here that golang's **for range** loop returns the index of the iteration followed by the actual type's value of the interation. This corrsponds to `x, column :=` and `y, tile :=` as we are using both the indices and the data for both range loops.

With these changes in place, we can now rebuild the project and you should see much more color and be able to be blocked by the tiles rendered as walls.

## Topics Covered
Here we have increased the functionality of our `DrawAll` function to allow rendering the game map.

## What's Next
With this, we are done with part 2. Part 3 will consist of randomly generating a dungeon.
